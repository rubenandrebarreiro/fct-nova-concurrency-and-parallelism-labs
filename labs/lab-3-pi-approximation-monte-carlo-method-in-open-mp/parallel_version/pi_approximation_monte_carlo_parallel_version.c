/**
 *
 * Pi Approximation/Estimation, for the Monte Carlo Method,
 * using Sequential and Parallel Versions (Version in OpenMP)
 *
 * @author: Ruben Andre Barreiro
 * @email: r.barreiro@campus.fct.unl.pt
 * @number_student: 42648
 *
 * NOVA School of Science and Technology | NOVA University of Lisbon (FCT NOVA)
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <omp.h>

// The Circle has Radius of 1
#define CIRCLE_RADIUS 1

// The Method for the Pi Approximation, by the Parallel Version
void *parallel_pi_approximation(const long *arg_num_points, const int *arg_num_threads) {

    // The total number of Points, to be generated, during the Simulation
    long *total_num_points;
    total_num_points = (long *) malloc(sizeof(long));
    *total_num_points = *arg_num_points;

    // The number of Threads to be launched, in Parallel
    int *num_threads;
    num_threads = (int *) malloc(sizeof(int));
    *num_threads = *arg_num_threads;

    // The number of Points, to be generated, individually, by each Thread
    long *num_points_per_thread;
    num_points_per_thread = (long *) malloc(sizeof(long));
    *num_points_per_thread = (*total_num_points / *num_threads);

    // The number of remaining Points to be generated by the last Thread
    long *num_remaining_points_for_last_thread;
    num_remaining_points_for_last_thread = (long *) malloc(sizeof(long));
    *num_remaining_points_for_last_thread = (*total_num_points % *num_threads);

    // The number of Points, to be generated by the last Thread,
    // for the case of the total number of Points to be generated,
    // are not divisible for the number of Threads
    long *num_points_for_last_thread;
    num_points_for_last_thread = (long *) malloc(sizeof(long));
    *num_points_for_last_thread = (*num_points_per_thread + *num_remaining_points_for_last_thread);

    // The total number of Hit Counts, within the Circle
    long *total_inside_hits_count;
    total_inside_hits_count = (long *) malloc(sizeof(long));
    *total_inside_hits_count = 0;

    // The ID of the Thread (will be set as a Private Variable)
    int thread_id;

    // The current number of Thread (will be set as a Private Variable)
    int current_thread;

    // The array for the individual Hit Counts, in Parallel, for the Threads
    long parallel_inside_hits_count[*num_threads];

    // The Hit Counts, for each Thread, individually, in Parallel
    // (will be set as a Private Variable)
    long thread_inside_hits_count;

    // The Random Seed, for each Thread, individually, in Parallel
    // (will be set as a Private Variable)
    unsigned int random_seed;

    // Set the number of Threads given, as argument,
    // as the flag of Number of Threads to be used by the OpenMP
    omp_set_num_threads(*num_threads);

    // For each Thread, in Sequential
    for(current_thread = 0; current_thread < *num_threads; current_thread++) {

        // Initialise the individual Hit Counts, in Parallel, for the Threads
        parallel_inside_hits_count[current_thread] = 0;

    }

    // Parallel Loop, in OpenMP, for each Thread, individually:
    // - Private Variables for each Thread: thread_id, current_thread, thread_inside_hits_count, random_seed
    // - Number of Threads to be launched, in the Parallel Loop: num_threads
    // - Shared Variables by all the Threads: num_threads, num_points_per_thread, parallel_inside_hits_count
    #pragma omp parallel for private(thread_id, current_thread, thread_inside_hits_count, random_seed) num_threads(*num_threads) shared(num_threads, num_points_per_thread, parallel_inside_hits_count)
    for(current_thread = 0; current_thread < *num_threads; current_thread++) {

        // Set the Private Variable for the ID of the current Thread
        thread_id = omp_get_thread_num();

        // Initialise the Hit Counts, for each Thread, individually, in Parallel
        thread_inside_hits_count = 0L;

        // Initialise the Random Seed, for each Thread, individually, in Parallel
        random_seed = time(NULL);

        // If the current Thread's ID does not belong to the last Thread
        if (thread_id < (*num_threads - 1)) {

            // For each Point to be generated, individually, in Parallel, by each Thread
            for (int current_point = 0; current_point < *num_points_per_thread; current_point++) {

                // Generate the random coordinates for the Point, using the Pseudo-Random Generator,
                // individually, in Parallel, by each Thread
                float point_x = (((float) rand_r(&random_seed)) / ((float) (RAND_MAX)));
                float point_y = (((float) rand_r(&random_seed)) / ((float) (RAND_MAX)));

                // Compute the Pythagoras formula
                double pythagoras_formula = ((point_x * point_x) + (point_y * point_y));

                // If the Point currently generated, is within the Circle
                if( pythagoras_formula <= CIRCLE_RADIUS ) {

                    // Increment the number of Hit Counts, within the Circle
                    thread_inside_hits_count += 1;

                }

            }

        }
        // If the current Thread's ID belongs to the last Thread
        else {

            // For each Point to be generated, individually, in Parallel, by the last Thread
            for (int current_point = 0; current_point < *num_points_for_last_thread; current_point++) {

                // Generate the random coordinates for the Point, using the Pseudo-Random Generator,
                // individually, in Parallel, by the last Thread
                float point_x = (((float) rand_r(&random_seed)) / ((float) (RAND_MAX)));
                float point_y = (((float) rand_r(&random_seed)) / ((float) (RAND_MAX)));

                // Compute the Pythagoras formula
                double pythagoras_formula = ((point_x * point_x) + (point_y * point_y));

                // If the Point currently generated, is within the Circle
                if( pythagoras_formula <= CIRCLE_RADIUS ) {

                    // Increment the number of Hit Counts, within the Circle
                    thread_inside_hits_count += 1;

                }

            }

        }

        // Set the final individual Hit Counts, in Parallel, for the Threads,
        // to be collected after the Parallel computation
        parallel_inside_hits_count[current_thread] = thread_inside_hits_count;

    }

    // For each Thread, in Sequential
    for(current_thread = 0; current_thread < *num_threads; current_thread++) {

        // Collect the final individual Hit Counts, in Parallel, for the Threads,
        // computed previously, adding them to the final total number of Hit Counts,
        // within the Circle
        *total_inside_hits_count += parallel_inside_hits_count[current_thread];

    }

    // Return the total number of Hit Counts, within the Circle
    return total_inside_hits_count;

}

// The Method for printing the Results of the Pi Approximation, by the Parallel Version
int print_final_results_parallel_pi_approximation(const long *arg_num_points,
                                                  const int *arg_num_threads,
                                                  const long *arg_inside_hits_count) {

    // The total number of Points, for the Simulation
    long *total_num_points;
    total_num_points = (long *) malloc(sizeof(long));
    *total_num_points = *arg_num_points;

    // The number of Threads, used in the Simulation
    int *num_threads;
    num_threads = (int *) malloc(sizeof(int));
    *num_threads = *arg_num_threads;

    // The number of Points, within the Circle
    long *inside_hits_count;
    inside_hits_count = (long *) malloc(sizeof(long));
    *inside_hits_count = *arg_inside_hits_count;

    // The Pi Estimation, by the computation of the Points within the Circle
    double *pi_estimation;
    pi_estimation = (double *) malloc(sizeof(double));
    *pi_estimation = (double) ( 4 * ( (float) ( ( (double) *inside_hits_count ) / ( (double) *total_num_points ) ) ) );

    // Print the Final Results
    printf("--- Pi Approximation (Monte Carlo Method) [Parallel, with %d Thread(s)] ---\n", *num_threads);
    printf("Total Number of Points: %ld\n", *total_num_points);
    printf("Points within Circle: %ld\n", *inside_hits_count);
    printf("Pi Estimation: %1.5f\n", *pi_estimation);

    // Return from the function
    return 0;

}